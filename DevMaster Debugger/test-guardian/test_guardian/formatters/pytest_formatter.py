"""Pytest formatter - generates pytest test files"""

from typing import List
from pathlib import Path

from ..models import TestSuite, TestCase, TestType, Fixture, MockSpec


class PytestFormatter:
    """Formats test suites as pytest code"""

    def format_test_suite(self, test_suite: TestSuite) -> str:
        """Generate complete pytest test file"""
        lines = []

        # Header
        lines.append('"""')
        lines.append(f"Auto-generated tests for {test_suite.target}")
        lines.append("Generated by Test-Guardian")
        lines.append('"""')
        lines.append('')

        # Imports
        lines.extend(self._generate_imports(test_suite))
        lines.append('')

        # Fixtures
        if test_suite.fixtures:
            lines.extend(self._generate_fixtures(test_suite.fixtures))
            lines.append('')

        # Test cases
        for test_case in test_suite.test_cases:
            lines.extend(self._generate_test_case(test_case, test_suite.mocks))
            lines.append('')

        return '\n'.join(lines)

    def _generate_imports(self, test_suite: TestSuite) -> List[str]:
        """Generate import statements"""
        imports = [
            "import pytest",
        ]

        # Add unittest.mock if needed
        if test_suite.mocks:
            imports.append("from unittest.mock import Mock, patch, MagicMock")

        # Add module imports
        module_name = Path(test_suite.file_path).stem
        imports.append(f"from {module_name} import {test_suite.target}")

        # Add any custom imports
        for imp in sorted(test_suite.imports):
            imports.append(imp)

        return imports

    def _generate_fixtures(self, fixtures: List[Fixture]) -> List[str]:
        """Generate fixture definitions"""
        lines = []

        for fixture in fixtures:
            lines.append(fixture.code)

        return lines

    def _generate_test_case(
        self,
        test_case: TestCase,
        mocks: List[MockSpec]
    ) -> List[str]:
        """Generate a single test function"""
        lines = []

        # Function signature
        params = []
        if test_case.requires_fixture:
            # Add fixture parameters
            for inp in test_case.inputs:
                if self._is_complex_type(inp.type_hint):
                    params.append(f"{inp.name}_fixture")

        func_signature = f"def {test_case.name}({', '.join(params)}):"
        lines.append(func_signature)

        # Docstring
        lines.append(f'    """{test_case.description}"""')

        # Setup mocks if needed
        if test_case.requires_mock and mocks:
            for mock in mocks:
                lines.append(f"    # Mock {mock.target}")
                lines.append(f"    mock_{mock.target.split('.')[-1]} = Mock(return_value={mock.return_value})")

        # Arrange
        lines.append("    # Arrange")
        for inp in test_case.inputs:
            value_repr = self._format_value(inp.value)
            lines.append(f"    {inp.name} = {value_repr}")

        # Act
        lines.append("")
        lines.append("    # Act")

        args = ", ".join(inp.name for inp in test_case.inputs)

        if test_case.test_type == TestType.ERROR:
            # Expect exception
            exception = test_case.expected_exception or "Exception"
            lines.append(f"    with pytest.raises({exception}):")
            lines.append(f"        result = {test_case.function_name}({args})")
        else:
            # Normal execution
            lines.append(f"    result = {test_case.function_name}({args})")

            # Assert
            lines.append("")
            lines.append("    # Assert")
            if test_case.expected_output == "PLACEHOLDER":
                lines.append("    # TODO: Add assertion - replace with expected value")
                lines.append("    assert result is not None")
            elif test_case.expected_output == "PROPERTY":
                lines.append("    # TODO: Add property assertions")
                lines.append("    assert result is not None")
            else:
                expected_repr = self._format_value(test_case.expected_output)
                lines.append(f"    assert result == {expected_repr}")

        return lines

    def _is_complex_type(self, type_hint: str) -> bool:
        """Check if type is complex enough to need a fixture"""
        if not type_hint:
            return False
        return any(t in type_hint.lower() for t in ['dict', 'list', 'dataclass'])

    def _format_value(self, value: Any) -> str:
        """Format a value for Python code"""
        if value is None:
            return "None"
        elif isinstance(value, str):
            if value == "PLACEHOLDER":
                return "None  # TODO: Replace with expected value"
            return f'"{value}"'
        elif isinstance(value, (int, float, bool)):
            return str(value)
        elif isinstance(value, list):
            return str(value)
        elif isinstance(value, dict):
            return str(value)
        else:
            return repr(value)

    def save_test_file(self, test_suite: TestSuite, output_path: Path) -> None:
        """Save test suite to file"""
        code = self.format_test_suite(test_suite)

        with open(output_path, 'w') as f:
            f.write(code)

        # Format with black if available
        try:
            import black
            formatted = black.format_str(code, mode=black.Mode())
            with open(output_path, 'w') as f:
                f.write(formatted)
        except:
            pass  # black not available, keep unformatted
